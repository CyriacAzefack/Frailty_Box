<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1, minimum-scale=1" name="viewport"/>
    <meta content="pdoc 0.9.2" name="generator"/>
    <title>Graph_Model.Graph_Pattern API documentation</title>
    <meta content="" name="description"/>
    <link as="style" crossorigin href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
          integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" rel="preload stylesheet">
    <link as="style" crossorigin
          href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
          integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" rel="preload stylesheet">
    <link as="style" crossorigin href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css"
          rel="stylesheet preload">
    <style>
        :root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}
    </style>
    <style media="screen and (min-width: 700px)">
        @media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}
    </style>
    <style media="print">
        @media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}
    </style>
    <script crossorigin defer integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8="
            src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
    <script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
    <article id="content">
        <header>
            <h1 class="title">Module <code>Graph_Model.Graph_Pattern</code></h1>
        </header>
        <section id="section-intro">
            <details class="source">
                <summary>
                    <span>Expand source code</span>
                </summary>
                <pre><code class="python"># -*- coding: utf-8 -*-
import datetime as dt
import os
import sys
from pprint import pprint
from random import random
from subprocess import check_call

import Pattern2Graph
import matplotlib.image as mpimg
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import pandas as pd
import scipy.stats as st
import seaborn as sns

sns.set_style(&#34;darkgrid&#34;)


sys.path.append(os.path.join(os.path.dirname(__file__)))
from Pattern_Mining.Candidate_Study import modulo_datetime


class Graph:
    ID = 0
    NB_PERIODS_SLIDING_WINDOW = dt.timedelta(days=5)
    START_NODE = &#34;START PERIOD&#34;
    NONE_NODE = &#34;END&#34;
    COMPATIBILITY_MATRIX = None
    ACTIVITIES = None

    def __init__(self, nodes, labels, period, mu, sigma, prob_matrix, wait_matrix, activities_duration):
        &#39;&#39;&#39;
        Initialization of one Pattern_Graph
        :param nodes: starts with &#34;START_PERIOD&#34;
        :param labels: labels of the Pattern
        :param period:
        :param mu:
        :param sigma:
        :param prob_matrix:
        :param wait_matrix:
        &#39;&#39;&#39;

        Graph.ID += 1

        self.graph_nodes = nodes  # len(graph_nodes) = n
        self.labels = labels # len(labels) = l
        self.graph_labels = labels + [Graph.NONE_NODE]  # len (graph_labels) = l + 1
        self.period = period
        self.sliding_time_window = Graph.NB_PERIODS_SLIDING_WINDOW
        self.mu = mu
        self.sigma = sigma
        self.prob_matrix = prob_matrix  # size = (n x l+1)
        self.time_matrix = wait_matrix  # size = (n x l+1)
        self.activities_duration = activities_duration
        self.ID = Graph.ID
        self.graph = None
        self.time_evo_prob_matrix = None
        self.time_evo_time_matrix = None



    def __repr__(self):
        &#39;&#39;&#39;
        :return: Text description of a graph pattern
        &#39;&#39;&#39;
        txt = &#39;Graph Pattern ID NÂ°{}\n&#39;.format(self.ID)
        txt += &#39;Labels : {}\n&#39;.format(self.labels)
        txt += &#39;Period : {}\n&#39;.format(self.period)
        txt += &#39;Mean Time : {}\n&#39;.format(dt.timedelta(seconds=self.mu))
        txt += &#39;Std Time : {}\n&#39;.format(dt.timedelta(seconds=self.sigma))

        return txt

    def get_prob_matrix(self):
        return self.prob_matrix

    def get_time_matrix(self):
        return self.time_matrix

    def get_nodes(self):
        return self.graph_nodes

    def display(self, output_folder, debug=False):
        td = dt.timedelta(seconds=self.mu)
        filename = &#39;directed_graph_{}_{}_{}&#39;.format(td.days, td.seconds // 3600, (td.seconds // 60) % 60)

        title = &#39;Period : &#39; + str(self.period) + &#39;\n&#39;
        title += &#39;Mean Time : &#39; + str(td) + &#39;  ---   Std Time : &#39; + str(dt.timedelta(seconds=self.sigma))

        self.draw_directed_graph(filename=output_folder + filename,
                                 title=title, debug=debug)

    def get_index(self):
        return self.ID

    def draw_directed_graph(self, filename, title, debug=False):
        &#39;&#39;&#39;
        Draw the directed graph corresponding and save the image
        :param graph_nodes: Nodes of the graph
        :param prob_matrix: Transition distance_matrix
        :param filename: File path where the graph image is saved
        :param debug: If True, plot the image
        :return:
        &#39;&#39;&#39;
        Q = pd.DataFrame(self.prob_matrix)
        Q.columns = self.graph_labels
        Q.index = self.graph_nodes
        edges_wts = self.get_markov_edges(Q)

        # create graph object
        G = nx.MultiDiGraph()

        # graph_nodes correspond to states
        # G.add_nodes_from(self.graph_nodes)

        G.graph[&#39;graph&#39;] = {&#39;label&#39;: title, &#39;labelloc&#39;: &#39;t&#39;, &#39;fontsize&#39;: &#39;20 &#39;, &#39;fontcolor&#39;: &#39;blue&#39;,
                            &#39;fontname&#39;: &#39;times-bold&#39;}  # default
        # edges represent transition probabilities
        for k, prob in edges_wts.items():
            tmp_origin, tmp_destination = k[0], k[1]

            # Add Origin Node
            if tmp_origin == Graph.START_NODE:
                G.add_node(tmp_origin, color=&#39;black&#39;, style=&#39;filled&#39;, fillcolor=&#39;red&#39;)
            else:
                G.add_node(tmp_origin, color=&#39;green&#39;)

            # Add Destination Node
            if tmp_destination == Graph.NONE_NODE:
                G.add_node(tmp_destination, color=&#39;black&#39;, style=&#39;filled&#39;, fillcolor=&#39;blue&#39;)
            else:

                G.add_node(tmp_destination, color=&#39;green&#39;)
                # G.add_node(tmp_destination, color=&#39;green&#39;)

            # Add Edge

            G.add_edge(tmp_origin, tmp_destination, weight=prob, penwidth=2 if prob &gt; 0.5 else 1, label=prob,
                       color=&#39;blue&#39; if prob &gt; 0.5 else &#39;black&#39;)

            # Add Edge with waiting time label
            # G.add_edge(tmp_origin, tmp_destination, weight=v, penwidth=2 if v &gt; 0.5 else 1, label=v,
            #                 color=&#39;blue&#39; if v &gt; 0.5 else &#39;black&#39;,
            #                 headlabel=self.time_matrix[self.graph_nodes.period_ts_index(tmp_origin)][self.labels.period_ts_index(destination_label)])
        if debug:
            print(&#39;Edges:&#39;)
            pprint(G.edges(data=True))
        # pprint(G.graph.get(&#39;graph&#39;, {}))

        pos = nx.drawing.nx_pydot.graphviz_layout(G, prog=&#39;dot&#39;)
        nx.draw_networkx(G, pos)

        # create edge labels for jupyter plot but is not necessary
        edge_labels = {(n1, n2): d[&#39;label&#39;] for n1, n2, d in G.edges(data=True)}

        nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

        nx.drawing.nx_pydot.write_dot(G, filename + &#39;.dot&#39;)
        check_call([&#39;dot&#39;, &#39;-Tpng&#39;, filename + &#39;.dot&#39;, &#39;-o&#39;, filename + &#39;.png&#39;])
        self.graph = G
        if debug:
            plt.clf()
            plt.axis(&#39;off&#39;)
            img = mpimg.imread(filename + &#39;.png&#39;)
            plt.imshow(img)
            plt.show()


    def get_markov_edges(self, Q):
        &#39;&#39;&#39;
        Return the edges of the graph
        :param Q:
        :return:
        &#39;&#39;&#39;
        edges = {}
        for col in Q.columns:
            for idx in Q.index:
                if Q.loc[idx, col] != 0:
                    # Build the name of the transition
                    lvl = 0
                    if idx != Graph.START_NODE:
                        lvl = int(idx[idx.rindex(&#39;_&#39;)+1:]) + 1

                    node_name = col
                    if col != Graph.NONE_NODE:
                        node_name = col + &#39;_&#39; + str(lvl)
                    edges[(idx, node_name)] = round(Q.loc[idx, col], 3)
        return edges

    def simulate(self, previous_data, start_date, end_date):
        &#34;&#34;&#34;
        Simulate the current graph for the given period of time
        :param start_date:
        :param end_date:
        :return:
        &#34;&#34;&#34;
        # self.extrapolate_time_evolution(start_date)
        # prob_matrix, time_matrix = self.get_date_status(start_date)
        # time_matrix = self.time_matrix

        prob_matrix, time_matrix = self.prob_matrix, self.time_matrix

        l = len(self.graph_labels)

        result = pd.DataFrame(columns=[&#34;date&#34;, &#34;end_date&#34;, &#34;label&#34;])

        # The real &#39;start_date&#39; is the beginning of the next period
        start_date_rel = modulo_datetime(start_date, self.period)
        if start_date_rel != 0:
            start_date = start_date + dt.timedelta(seconds=self.period.total_seconds() - start_date_rel)

        current_state = Graph.START_NODE
        current_date = start_date

        while current_date &lt; end_date:
            state_index = self.graph_nodes.index(current_state)
            row = prob_matrix[state_index, :]
            cs_row = np.cumsum(row)

            # Pick a random number between 0 -- 1
            rand = random()
            destination_index = None

            for index in range(l):
                if rand &lt;= cs_row[index]:
                    destination_index = index
                    break

            if destination_index is None or destination_index == l - 1:  # We reached one end of the graph
                destination_state = Graph.START_NODE # Come back to the beginning

                # We move to the start of the next period
                destination_date = current_date + dt.timedelta(
                    seconds=self.period.total_seconds() - modulo_datetime(current_date, self.period))

            else:

                # Turn the column label to a node name
                lvl = 0
                if current_state != Graph.START_NODE:
                    lvl = int(current_state[current_state.rindex(&#39;_&#39;) + 1:]) + 1
                destination_state = self.graph_labels[destination_index] + &#39;_&#39; + str(lvl)

                destination_label = destination_state[
                                    0: destination_state.rindex(&#39;_&#39;)]  # We remove everything after the last &#39;_&#39;

                tuple = time_matrix[state_index][destination_index]
                dist_name = tuple[0]
                param = tuple[1:][0]
                dist = getattr(st, dist_name)

                activity_duration = self.activities_duration[self.graph_nodes.index(destination_state)]
                duration_dist_name = activity_duration[0]
                duration_param = activity_duration[1:][0]
                duration_dist = getattr(st, duration_dist_name)
                # Separate parts of parameters

                compatibabilty_respected = False

                nb_ite = 10
                activity_start_date, activity_end_date = None, None
                while not compatibabilty_respected &amp; nb_ite &gt; 0:
                    nb_ite -= 1
                    activity_start_date, activity_end_date = self.generate_activity(current_date, waiting_dist=dist,
                                                                                    waiting_param=param,
                                                                                    duration_dist=duration_dist,
                                                                                    duration_param=duration_param)
                    compatibabilty_respected = True

                    date_filter = ((previous_data.date &lt; activity_start_date) &amp; (
                            previous_data.end_date &gt; activity_start_date)) | (
                                          (previous_data.end_date &gt; activity_end_date) &amp; (
                                          previous_data.date &lt; activity_end_date)) | (
                                          (previous_data.date &gt; activity_start_date) &amp; (
                                          previous_data.end_date &lt; activity_end_date))

                    filtered_data = previous_data.loc[date_filter]
                    if not filtered_data.empty:
                        filtered_activities = filtered_data.label.unique()
                        for filtered_activity in filtered_activities:
                            if Graph.COMPATIBILITY_MATRIX[Graph.ACTIVITIES.index(destination_label)][
                                Graph.ACTIVITIES.index(filtered_activity)] == 0:
                                compatibabilty_respected = False

                if nb_ite &gt; 0:
                    result.loc[len(result)] = [activity_start_date, activity_end_date, destination_label]
                destination_date = activity_start_date


            current_state = destination_state
            current_date = destination_date

        return result

    def compute_time_evolution(self, data, nb_patterns):
        &#39;&#39;&#39;
        Compute the pattern time evolution by sliding a time window through the original data
        :param data:
        :return:
        &#39;&#39;&#39;

        n = len(self.graph_nodes)
        l = len(self.graph_labels)
        nb_days_per_periods = self.period.days

        start_date = data.date.min().to_pydatetime()
        # We start at the beginning of the first period
        start_date = start_date - dt.timedelta(seconds=modulo_datetime(start_date, self.period))
        end_date = data.date.max().to_pydatetime()

        time_evo_prob_matrix = [
            [pd.DataFrame(index=pd.date_range(start_date, end_date, freq=str(nb_days_per_periods) + &#39;D&#39;),
                          columns=[&#39;probability&#39;]).fillna(0) for j in range(l)] for i in
            range(n)]  # Date as period_ts_index

        time_evo_time_matrix = [
            [pd.DataFrame(index=pd.date_range(start_date, end_date, freq=str(nb_days_per_periods) + &#39;D&#39;),
                          columns=[&#39;mean_time&#39;, &#39;sigma_time&#39;]).fillna(0) for j in range(l)] for i in
            range(n)]  # Date as period_ts_index

        # We take the time window into account for the end_date
        end_date = end_date - self.sliding_time_window

        nb_periods = int((end_date - start_date).total_seconds() / self.period.total_seconds()) + 1

        period_index = 0
        current_start_date = start_date

        while current_start_date &lt; end_date:
            current_end_date = current_start_date + self.sliding_time_window
            time_description = {self.mu: self.sigma}
            mini_graph_pattern = Pattern2Graph.pattern2graph(data, labels=self.labels, time_description=time_description,
                                                             period=self.period, start_date=current_start_date,
                                                             end_date=current_end_date, display_graph=False)

            if len(mini_graph_pattern) == 0:
                current_start_date += self.period
                continue

            mini_graph_pattern = mini_graph_pattern[0] # Since we have one time_description, we have one graph to fetch
            mini_prob_matrix = mini_graph_pattern.get_prob_matrix()
            mini_time_matrix = mini_graph_pattern.get_time_matrix()
            mini_nodes = mini_graph_pattern.get_nodes()

            # Fill time_evo_prob_matrix and time_evo_time_matrix
            for mini_node_i in mini_nodes:
                for label in self.graph_labels:
                    mini_i = mini_nodes.index(mini_node_i)
                    big_i = self.graph_nodes.index(mini_node_i)
                    j = self.graph_labels.index(label)

                    prob_df = time_evo_prob_matrix[big_i][j]
                    prob_df.loc[current_start_date] = mini_prob_matrix[mini_i, j]

                    if mini_time_matrix[mini_i][j]:
                        time_df = time_evo_time_matrix[big_i][j]

                        # TODO : Manage with other distribution than &#39;norm&#39;
                        time_df.loc[current_start_date] = [mini_time_matrix[mini_i][j][1][0],
                                                           mini_time_matrix[mini_i][j][1][1]]

            current_start_date += self.period
            evolution_percentage = round(100 * (period_index + 1) / nb_periods, 2)
            sys.stdout.write(&#34;\r{} %% of time evolution computed for the GRAPH NÂ°{}/{}!!&#34;.format(evolution_percentage,
                                                                                                 self.ID, nb_patterns))
            sys.stdout.flush()
            period_index += 1
        sys.stdout.write(&#34;\n&#34;)

        self.time_evo_prob_matrix = time_evo_prob_matrix
        self.time_evo_time_matrix = time_evo_time_matrix

    def get_date_status(self, start_date):
        # We start at the beginning of the first period
        start_date = start_date - dt.timedelta(seconds=modulo_datetime(start_date, self.period))

        n = len(self.graph_nodes)
        l = len(self.graph_labels)

        prob_matrix = [[self.time_evo_prob_matrix[i][j].loc[start_date, &#34;probability&#34;] for j in range(l)] for i in
                       range(n)]
        prob_matrix = np.array(prob_matrix)
        prob_matrix.reshape((n, l))

        time_matrix = [[self.time_evo_time_matrix[i][j].loc[start_date, [&#34;mean_time&#34;, &#34;sigma_time&#34;]].values
                        for j in range(l)] for i in range(n)]
        for i in range(n):
            for j in range(l):
                time_matrix[i][j] = (&#39;norm&#39;, time_matrix[i][j])

        return prob_matrix, time_matrix

    def extrapolate_time_evolution(self, start_date):
        &#39;&#39;&#39;
        Compute the probability transition distance_matrix and the waiting time transition distance_matrix by extrapolating time evolution
        :param start_date:
        :param end_date:
        :return: (prob_matrix, time_matrix)
        &#39;&#39;&#39;

        n = len(self.graph_nodes)
        l = len(self.graph_labels)
        extr_prob_matrix = np.zeros((n, l))
        extr_time_matrix = [[[] for j in range(l)] for i in range(n)]  # Empty lists

        for i in range(n):
            fig, (ax1, ax2) = plt.subplots(2)
            for j in range(l):
                txt = &#34;--&gt; [{}]&#34;.format(self.graph_labels[j])
                df = self.time_evo_prob_matrix[i][j]
                ax1.plot_date(df.index, df.probability, label=txt, linestyle=&#34;-&#34;)
                df = self.time_evo_time_matrix[i][j]
                ax2.plot_date(df.index, df.mean_time / 60, label=txt, linestyle=&#34;-&#34;)
            ax1.title.set_text(&#39;From Node [{}]\nProbability transition&#39;.format(self.graph_nodes[i]))
            ax1.set_ylabel(&#39;Transition probability&#39;)
            ax2.set_ylabel(&#39;Mean Time (min)&#39;)
            ax2.set_xlabel(&#39;Date&#39;)
            ax2.set_title(&#39;Waiting Time transition&#39;)
            ax1.legend(loc=&#34;upper left&#34;)
            ax2.legend(loc=&#34;upper left&#34;)
            plt.gcf().autofmt_xdate()
            plt.show()

    def generate_activity(self, date, waiting_dist, waiting_param, duration_dist, duration_param):
        &#34;&#34;&#34;
        Generate a date interval respecting the constraints
        :param date:
        :param waiting_dist:
        :param waiting_param:
        :param duration_dist:
        :param duration_param:
        :return:
        &#34;&#34;&#34;

        waiting_arg = waiting_param[:-2]
        waiting_loc = waiting_param[-2]
        waiting_scale = waiting_param[-1]

        duration_arg = duration_param[:-2]
        duration_loc = duration_param[-2]
        duration_scale = duration_param[-1]

        start_date = None
        end_date = None
        while True:

            waiting_time = int(waiting_dist.rvs(loc=waiting_loc, scale=waiting_scale, *waiting_arg))

            duration = -1
            while duration &lt; 0:
                duration = int(duration_dist.rvs(loc=duration_loc, scale=duration_scale, *duration_arg))

            try:
                start_date = date + dt.timedelta(seconds=waiting_time)
                end_date = start_date + dt.timedelta(seconds=duration)
                break;
            except ValueError as e:
                print(e)
                print(&#34;OOOps ! Date Overflow. Let&#39;s try again...&#34;)

        return start_date, end_date

    @staticmethod
    def node2label(txt):
        &#39;&#39;&#39;
        turn a node name to the label name
        :param str:
        :return:
        &#39;&#39;&#39;
        return txt[0: txt.rindex(&#39;_&#39;)]  # We remove everything after the last &#39;_&#39;

    @staticmethod
    def set_compatibility_matrix(activities, matrix):
        Graph.ACTIVITIES = activities
        Graph.COMPATIBILITY_MATRIX = matrix</code></pre>
            </details>
        </section>
        <section>
        </section>
        <section>
        </section>
        <section>
            <h2 class="section-title" id="header-functions">Functions</h2>
            <dl>
                <dt id="Graph_Model.Graph_Pattern.random"><code class="name flex">
                    <span>def <span class="ident">random</span></span>(<span>)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>random() -&gt; x in the interval [0, 1).</p></div>
                </dd>
            </dl>
        </section>
        <section>
            <h2 class="section-title" id="header-classes">Classes</h2>
            <dl>
                <dt id="Graph_Model.Graph_Pattern.Graph"><code class="flex name class">
                    <span>class <span class="ident">Graph</span></span>
                    <span>(</span><span>nodes, labels, period, mu, sigma, prob_matrix, wait_matrix, activities_duration)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>Initialization of one Pattern_Graph
                        :param nodes: starts with "START_PERIOD"
                        :param labels: labels of the Pattern
                        :param period:
                        :param mu:
                        :param sigma:
                        :param prob_matrix:
                        :param wait_matrix:</p></div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">class Graph:
    ID = 0
    NB_PERIODS_SLIDING_WINDOW = dt.timedelta(days=5)
    START_NODE = &#34;START PERIOD&#34;
    NONE_NODE = &#34;END&#34;
    COMPATIBILITY_MATRIX = None
    ACTIVITIES = None

    def __init__(self, nodes, labels, period, mu, sigma, prob_matrix, wait_matrix, activities_duration):
        &#39;&#39;&#39;
        Initialization of one Pattern_Graph
        :param nodes: starts with &#34;START_PERIOD&#34;
        :param labels: labels of the Pattern
        :param period:
        :param mu:
        :param sigma:
        :param prob_matrix:
        :param wait_matrix:
        &#39;&#39;&#39;

        Graph.ID += 1

        self.graph_nodes = nodes  # len(graph_nodes) = n
        self.labels = labels # len(labels) = l
        self.graph_labels = labels + [Graph.NONE_NODE]  # len (graph_labels) = l + 1
        self.period = period
        self.sliding_time_window = Graph.NB_PERIODS_SLIDING_WINDOW
        self.mu = mu
        self.sigma = sigma
        self.prob_matrix = prob_matrix  # size = (n x l+1)
        self.time_matrix = wait_matrix  # size = (n x l+1)
        self.activities_duration = activities_duration
        self.ID = Graph.ID
        self.graph = None
        self.time_evo_prob_matrix = None
        self.time_evo_time_matrix = None



    def __repr__(self):
        &#39;&#39;&#39;
        :return: Text description of a graph pattern
        &#39;&#39;&#39;
        txt = &#39;Graph Pattern ID NÂ°{}\n&#39;.format(self.ID)
        txt += &#39;Labels : {}\n&#39;.format(self.labels)
        txt += &#39;Period : {}\n&#39;.format(self.period)
        txt += &#39;Mean Time : {}\n&#39;.format(dt.timedelta(seconds=self.mu))
        txt += &#39;Std Time : {}\n&#39;.format(dt.timedelta(seconds=self.sigma))

        return txt

    def get_prob_matrix(self):
        return self.prob_matrix

    def get_time_matrix(self):
        return self.time_matrix

    def get_nodes(self):
        return self.graph_nodes

    def display(self, output_folder, debug=False):
        td = dt.timedelta(seconds=self.mu)
        filename = &#39;directed_graph_{}_{}_{}&#39;.format(td.days, td.seconds // 3600, (td.seconds // 60) % 60)

        title = &#39;Period : &#39; + str(self.period) + &#39;\n&#39;
        title += &#39;Mean Time : &#39; + str(td) + &#39;  ---   Std Time : &#39; + str(dt.timedelta(seconds=self.sigma))

        self.draw_directed_graph(filename=output_folder + filename,
                                 title=title, debug=debug)

    def get_index(self):
        return self.ID

    def draw_directed_graph(self, filename, title, debug=False):
        &#39;&#39;&#39;
        Draw the directed graph corresponding and save the image
        :param graph_nodes: Nodes of the graph
        :param prob_matrix: Transition distance_matrix
        :param filename: File path where the graph image is saved
        :param debug: If True, plot the image
        :return:
        &#39;&#39;&#39;
        Q = pd.DataFrame(self.prob_matrix)
        Q.columns = self.graph_labels
        Q.index = self.graph_nodes
        edges_wts = self.get_markov_edges(Q)

        # create graph object
        G = nx.MultiDiGraph()

        # graph_nodes correspond to states
        # G.add_nodes_from(self.graph_nodes)

        G.graph[&#39;graph&#39;] = {&#39;label&#39;: title, &#39;labelloc&#39;: &#39;t&#39;, &#39;fontsize&#39;: &#39;20 &#39;, &#39;fontcolor&#39;: &#39;blue&#39;,
                            &#39;fontname&#39;: &#39;times-bold&#39;}  # default
        # edges represent transition probabilities
        for k, prob in edges_wts.items():
            tmp_origin, tmp_destination = k[0], k[1]

            # Add Origin Node
            if tmp_origin == Graph.START_NODE:
                G.add_node(tmp_origin, color=&#39;black&#39;, style=&#39;filled&#39;, fillcolor=&#39;red&#39;)
            else:
                G.add_node(tmp_origin, color=&#39;green&#39;)

            # Add Destination Node
            if tmp_destination == Graph.NONE_NODE:
                G.add_node(tmp_destination, color=&#39;black&#39;, style=&#39;filled&#39;, fillcolor=&#39;blue&#39;)
            else:

                G.add_node(tmp_destination, color=&#39;green&#39;)
                # G.add_node(tmp_destination, color=&#39;green&#39;)

            # Add Edge

            G.add_edge(tmp_origin, tmp_destination, weight=prob, penwidth=2 if prob &gt; 0.5 else 1, label=prob,
                       color=&#39;blue&#39; if prob &gt; 0.5 else &#39;black&#39;)

            # Add Edge with waiting time label
            # G.add_edge(tmp_origin, tmp_destination, weight=v, penwidth=2 if v &gt; 0.5 else 1, label=v,
            #                 color=&#39;blue&#39; if v &gt; 0.5 else &#39;black&#39;,
            #                 headlabel=self.time_matrix[self.graph_nodes.period_ts_index(tmp_origin)][self.labels.period_ts_index(destination_label)])
        if debug:
            print(&#39;Edges:&#39;)
            pprint(G.edges(data=True))
        # pprint(G.graph.get(&#39;graph&#39;, {}))

        pos = nx.drawing.nx_pydot.graphviz_layout(G, prog=&#39;dot&#39;)
        nx.draw_networkx(G, pos)

        # create edge labels for jupyter plot but is not necessary
        edge_labels = {(n1, n2): d[&#39;label&#39;] for n1, n2, d in G.edges(data=True)}

        nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

        nx.drawing.nx_pydot.write_dot(G, filename + &#39;.dot&#39;)
        check_call([&#39;dot&#39;, &#39;-Tpng&#39;, filename + &#39;.dot&#39;, &#39;-o&#39;, filename + &#39;.png&#39;])
        self.graph = G
        if debug:
            plt.clf()
            plt.axis(&#39;off&#39;)
            img = mpimg.imread(filename + &#39;.png&#39;)
            plt.imshow(img)
            plt.show()


    def get_markov_edges(self, Q):
        &#39;&#39;&#39;
        Return the edges of the graph
        :param Q:
        :return:
        &#39;&#39;&#39;
        edges = {}
        for col in Q.columns:
            for idx in Q.index:
                if Q.loc[idx, col] != 0:
                    # Build the name of the transition
                    lvl = 0
                    if idx != Graph.START_NODE:
                        lvl = int(idx[idx.rindex(&#39;_&#39;)+1:]) + 1

                    node_name = col
                    if col != Graph.NONE_NODE:
                        node_name = col + &#39;_&#39; + str(lvl)
                    edges[(idx, node_name)] = round(Q.loc[idx, col], 3)
        return edges

    def simulate(self, previous_data, start_date, end_date):
        &#34;&#34;&#34;
        Simulate the current graph for the given period of time
        :param start_date:
        :param end_date:
        :return:
        &#34;&#34;&#34;
        # self.extrapolate_time_evolution(start_date)
        # prob_matrix, time_matrix = self.get_date_status(start_date)
        # time_matrix = self.time_matrix

        prob_matrix, time_matrix = self.prob_matrix, self.time_matrix

        l = len(self.graph_labels)

        result = pd.DataFrame(columns=[&#34;date&#34;, &#34;end_date&#34;, &#34;label&#34;])

        # The real &#39;start_date&#39; is the beginning of the next period
        start_date_rel = modulo_datetime(start_date, self.period)
        if start_date_rel != 0:
            start_date = start_date + dt.timedelta(seconds=self.period.total_seconds() - start_date_rel)

        current_state = Graph.START_NODE
        current_date = start_date

        while current_date &lt; end_date:
            state_index = self.graph_nodes.index(current_state)
            row = prob_matrix[state_index, :]
            cs_row = np.cumsum(row)

            # Pick a random number between 0 -- 1
            rand = random()
            destination_index = None

            for index in range(l):
                if rand &lt;= cs_row[index]:
                    destination_index = index
                    break

            if destination_index is None or destination_index == l - 1:  # We reached one end of the graph
                destination_state = Graph.START_NODE # Come back to the beginning

                # We move to the start of the next period
                destination_date = current_date + dt.timedelta(
                    seconds=self.period.total_seconds() - modulo_datetime(current_date, self.period))

            else:

                # Turn the column label to a node name
                lvl = 0
                if current_state != Graph.START_NODE:
                    lvl = int(current_state[current_state.rindex(&#39;_&#39;) + 1:]) + 1
                destination_state = self.graph_labels[destination_index] + &#39;_&#39; + str(lvl)

                destination_label = destination_state[
                                    0: destination_state.rindex(&#39;_&#39;)]  # We remove everything after the last &#39;_&#39;

                tuple = time_matrix[state_index][destination_index]
                dist_name = tuple[0]
                param = tuple[1:][0]
                dist = getattr(st, dist_name)

                activity_duration = self.activities_duration[self.graph_nodes.index(destination_state)]
                duration_dist_name = activity_duration[0]
                duration_param = activity_duration[1:][0]
                duration_dist = getattr(st, duration_dist_name)
                # Separate parts of parameters

                compatibabilty_respected = False

                nb_ite = 10
                activity_start_date, activity_end_date = None, None
                while not compatibabilty_respected &amp; nb_ite &gt; 0:
                    nb_ite -= 1
                    activity_start_date, activity_end_date = self.generate_activity(current_date, waiting_dist=dist,
                                                                                    waiting_param=param,
                                                                                    duration_dist=duration_dist,
                                                                                    duration_param=duration_param)
                    compatibabilty_respected = True

                    date_filter = ((previous_data.date &lt; activity_start_date) &amp; (
                            previous_data.end_date &gt; activity_start_date)) | (
                                          (previous_data.end_date &gt; activity_end_date) &amp; (
                                          previous_data.date &lt; activity_end_date)) | (
                                          (previous_data.date &gt; activity_start_date) &amp; (
                                          previous_data.end_date &lt; activity_end_date))

                    filtered_data = previous_data.loc[date_filter]
                    if not filtered_data.empty:
                        filtered_activities = filtered_data.label.unique()
                        for filtered_activity in filtered_activities:
                            if Graph.COMPATIBILITY_MATRIX[Graph.ACTIVITIES.index(destination_label)][
                                Graph.ACTIVITIES.index(filtered_activity)] == 0:
                                compatibabilty_respected = False

                if nb_ite &gt; 0:
                    result.loc[len(result)] = [activity_start_date, activity_end_date, destination_label]
                destination_date = activity_start_date


            current_state = destination_state
            current_date = destination_date

        return result

    def compute_time_evolution(self, data, nb_patterns):
        &#39;&#39;&#39;
        Compute the pattern time evolution by sliding a time window through the original data
        :param data:
        :return:
        &#39;&#39;&#39;

        n = len(self.graph_nodes)
        l = len(self.graph_labels)
        nb_days_per_periods = self.period.days

        start_date = data.date.min().to_pydatetime()
        # We start at the beginning of the first period
        start_date = start_date - dt.timedelta(seconds=modulo_datetime(start_date, self.period))
        end_date = data.date.max().to_pydatetime()

        time_evo_prob_matrix = [
            [pd.DataFrame(index=pd.date_range(start_date, end_date, freq=str(nb_days_per_periods) + &#39;D&#39;),
                          columns=[&#39;probability&#39;]).fillna(0) for j in range(l)] for i in
            range(n)]  # Date as period_ts_index

        time_evo_time_matrix = [
            [pd.DataFrame(index=pd.date_range(start_date, end_date, freq=str(nb_days_per_periods) + &#39;D&#39;),
                          columns=[&#39;mean_time&#39;, &#39;sigma_time&#39;]).fillna(0) for j in range(l)] for i in
            range(n)]  # Date as period_ts_index

        # We take the time window into account for the end_date
        end_date = end_date - self.sliding_time_window

        nb_periods = int((end_date - start_date).total_seconds() / self.period.total_seconds()) + 1

        period_index = 0
        current_start_date = start_date

        while current_start_date &lt; end_date:
            current_end_date = current_start_date + self.sliding_time_window
            time_description = {self.mu: self.sigma}
            mini_graph_pattern = Pattern2Graph.pattern2graph(data, labels=self.labels, time_description=time_description,
                                                             period=self.period, start_date=current_start_date,
                                                             end_date=current_end_date, display_graph=False)

            if len(mini_graph_pattern) == 0:
                current_start_date += self.period
                continue

            mini_graph_pattern = mini_graph_pattern[0] # Since we have one time_description, we have one graph to fetch
            mini_prob_matrix = mini_graph_pattern.get_prob_matrix()
            mini_time_matrix = mini_graph_pattern.get_time_matrix()
            mini_nodes = mini_graph_pattern.get_nodes()

            # Fill time_evo_prob_matrix and time_evo_time_matrix
            for mini_node_i in mini_nodes:
                for label in self.graph_labels:
                    mini_i = mini_nodes.index(mini_node_i)
                    big_i = self.graph_nodes.index(mini_node_i)
                    j = self.graph_labels.index(label)

                    prob_df = time_evo_prob_matrix[big_i][j]
                    prob_df.loc[current_start_date] = mini_prob_matrix[mini_i, j]

                    if mini_time_matrix[mini_i][j]:
                        time_df = time_evo_time_matrix[big_i][j]

                        # TODO : Manage with other distribution than &#39;norm&#39;
                        time_df.loc[current_start_date] = [mini_time_matrix[mini_i][j][1][0],
                                                           mini_time_matrix[mini_i][j][1][1]]

            current_start_date += self.period
            evolution_percentage = round(100 * (period_index + 1) / nb_periods, 2)
            sys.stdout.write(&#34;\r{} %% of time evolution computed for the GRAPH NÂ°{}/{}!!&#34;.format(evolution_percentage,
                                                                                                 self.ID, nb_patterns))
            sys.stdout.flush()
            period_index += 1
        sys.stdout.write(&#34;\n&#34;)

        self.time_evo_prob_matrix = time_evo_prob_matrix
        self.time_evo_time_matrix = time_evo_time_matrix

    def get_date_status(self, start_date):
        # We start at the beginning of the first period
        start_date = start_date - dt.timedelta(seconds=modulo_datetime(start_date, self.period))

        n = len(self.graph_nodes)
        l = len(self.graph_labels)

        prob_matrix = [[self.time_evo_prob_matrix[i][j].loc[start_date, &#34;probability&#34;] for j in range(l)] for i in
                       range(n)]
        prob_matrix = np.array(prob_matrix)
        prob_matrix.reshape((n, l))

        time_matrix = [[self.time_evo_time_matrix[i][j].loc[start_date, [&#34;mean_time&#34;, &#34;sigma_time&#34;]].values
                        for j in range(l)] for i in range(n)]
        for i in range(n):
            for j in range(l):
                time_matrix[i][j] = (&#39;norm&#39;, time_matrix[i][j])

        return prob_matrix, time_matrix

    def extrapolate_time_evolution(self, start_date):
        &#39;&#39;&#39;
        Compute the probability transition distance_matrix and the waiting time transition distance_matrix by extrapolating time evolution
        :param start_date:
        :param end_date:
        :return: (prob_matrix, time_matrix)
        &#39;&#39;&#39;

        n = len(self.graph_nodes)
        l = len(self.graph_labels)
        extr_prob_matrix = np.zeros((n, l))
        extr_time_matrix = [[[] for j in range(l)] for i in range(n)]  # Empty lists

        for i in range(n):
            fig, (ax1, ax2) = plt.subplots(2)
            for j in range(l):
                txt = &#34;--&gt; [{}]&#34;.format(self.graph_labels[j])
                df = self.time_evo_prob_matrix[i][j]
                ax1.plot_date(df.index, df.probability, label=txt, linestyle=&#34;-&#34;)
                df = self.time_evo_time_matrix[i][j]
                ax2.plot_date(df.index, df.mean_time / 60, label=txt, linestyle=&#34;-&#34;)
            ax1.title.set_text(&#39;From Node [{}]\nProbability transition&#39;.format(self.graph_nodes[i]))
            ax1.set_ylabel(&#39;Transition probability&#39;)
            ax2.set_ylabel(&#39;Mean Time (min)&#39;)
            ax2.set_xlabel(&#39;Date&#39;)
            ax2.set_title(&#39;Waiting Time transition&#39;)
            ax1.legend(loc=&#34;upper left&#34;)
            ax2.legend(loc=&#34;upper left&#34;)
            plt.gcf().autofmt_xdate()
            plt.show()

    def generate_activity(self, date, waiting_dist, waiting_param, duration_dist, duration_param):
        &#34;&#34;&#34;
        Generate a date interval respecting the constraints
        :param date:
        :param waiting_dist:
        :param waiting_param:
        :param duration_dist:
        :param duration_param:
        :return:
        &#34;&#34;&#34;

        waiting_arg = waiting_param[:-2]
        waiting_loc = waiting_param[-2]
        waiting_scale = waiting_param[-1]

        duration_arg = duration_param[:-2]
        duration_loc = duration_param[-2]
        duration_scale = duration_param[-1]

        start_date = None
        end_date = None
        while True:

            waiting_time = int(waiting_dist.rvs(loc=waiting_loc, scale=waiting_scale, *waiting_arg))

            duration = -1
            while duration &lt; 0:
                duration = int(duration_dist.rvs(loc=duration_loc, scale=duration_scale, *duration_arg))

            try:
                start_date = date + dt.timedelta(seconds=waiting_time)
                end_date = start_date + dt.timedelta(seconds=duration)
                break;
            except ValueError as e:
                print(e)
                print(&#34;OOOps ! Date Overflow. Let&#39;s try again...&#34;)

        return start_date, end_date

    @staticmethod
    def node2label(txt):
        &#39;&#39;&#39;
        turn a node name to the label name
        :param str:
        :return:
        &#39;&#39;&#39;
        return txt[0: txt.rindex(&#39;_&#39;)]  # We remove everything after the last &#39;_&#39;

    @staticmethod
    def set_compatibility_matrix(activities, matrix):
        Graph.ACTIVITIES = activities
        Graph.COMPATIBILITY_MATRIX = matrix</code></pre>
                    </details>
                    <h3>Class variables</h3>
                    <dl>
                        <dt id="Graph_Model.Graph_Pattern.Graph.ACTIVITIES"><code class="name">var <span class="ident">ACTIVITIES</span></code>
                        </dt>
                        <dd>
                            <div class="desc"></div>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.COMPATIBILITY_MATRIX"><code class="name">var <span
                                class="ident">COMPATIBILITY_MATRIX</span></code></dt>
                        <dd>
                            <div class="desc"></div>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.ID"><code class="name">var <span class="ident">ID</span></code>
                        </dt>
                        <dd>
                            <div class="desc"></div>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.NB_PERIODS_SLIDING_WINDOW"><code class="name">var <span
                                class="ident">NB_PERIODS_SLIDING_WINDOW</span></code></dt>
                        <dd>
                            <div class="desc"></div>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.NONE_NODE"><code class="name">var <span class="ident">NONE_NODE</span></code>
                        </dt>
                        <dd>
                            <div class="desc"></div>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.START_NODE"><code class="name">var <span class="ident">START_NODE</span></code>
                        </dt>
                        <dd>
                            <div class="desc"></div>
                        </dd>
                    </dl>
                    <h3>Static methods</h3>
                    <dl>
                        <dt id="Graph_Model.Graph_Pattern.Graph.node2label"><code class="name flex">
                            <span>def <span class="ident">node2label</span></span>(<span>txt)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>turn a node name to the label name
                                :param str:
                                :return:</p></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">@staticmethod
def node2label(txt):
    &#39;&#39;&#39;
    turn a node name to the label name
    :param str:
    :return:
    &#39;&#39;&#39;
    return txt[0: txt.rindex(&#39;_&#39;)]  # We remove everything after the last &#39;_&#39;</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.set_compatibility_matrix"><code class="name flex">
                            <span>def <span class="ident">set_compatibility_matrix</span></span>(<span>activities, matrix)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">@staticmethod
def set_compatibility_matrix(activities, matrix):
    Graph.ACTIVITIES = activities
    Graph.COMPATIBILITY_MATRIX = matrix</code></pre>
                            </details>
                        </dd>
                    </dl>
                    <h3>Methods</h3>
                    <dl>
                        <dt id="Graph_Model.Graph_Pattern.Graph.compute_time_evolution"><code class="name flex">
                            <span>def <span class="ident">compute_time_evolution</span></span>(<span>self, data, nb_patterns)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>Compute the pattern time evolution by sliding a time window through the
                                original data
                                :param data:
                                :return:</p></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def compute_time_evolution(self, data, nb_patterns):
    &#39;&#39;&#39;
    Compute the pattern time evolution by sliding a time window through the original data
    :param data:
    :return:
    &#39;&#39;&#39;

    n = len(self.graph_nodes)
    l = len(self.graph_labels)
    nb_days_per_periods = self.period.days

    start_date = data.date.min().to_pydatetime()
    # We start at the beginning of the first period
    start_date = start_date - dt.timedelta(seconds=modulo_datetime(start_date, self.period))
    end_date = data.date.max().to_pydatetime()

    time_evo_prob_matrix = [
        [pd.DataFrame(index=pd.date_range(start_date, end_date, freq=str(nb_days_per_periods) + &#39;D&#39;),
                      columns=[&#39;probability&#39;]).fillna(0) for j in range(l)] for i in
        range(n)]  # Date as period_ts_index

    time_evo_time_matrix = [
        [pd.DataFrame(index=pd.date_range(start_date, end_date, freq=str(nb_days_per_periods) + &#39;D&#39;),
                      columns=[&#39;mean_time&#39;, &#39;sigma_time&#39;]).fillna(0) for j in range(l)] for i in
        range(n)]  # Date as period_ts_index

    # We take the time window into account for the end_date
    end_date = end_date - self.sliding_time_window

    nb_periods = int((end_date - start_date).total_seconds() / self.period.total_seconds()) + 1

    period_index = 0
    current_start_date = start_date

    while current_start_date &lt; end_date:
        current_end_date = current_start_date + self.sliding_time_window
        time_description = {self.mu: self.sigma}
        mini_graph_pattern = Pattern2Graph.pattern2graph(data, labels=self.labels, time_description=time_description,
                                                         period=self.period, start_date=current_start_date,
                                                         end_date=current_end_date, display_graph=False)

        if len(mini_graph_pattern) == 0:
            current_start_date += self.period
            continue

        mini_graph_pattern = mini_graph_pattern[0] # Since we have one time_description, we have one graph to fetch
        mini_prob_matrix = mini_graph_pattern.get_prob_matrix()
        mini_time_matrix = mini_graph_pattern.get_time_matrix()
        mini_nodes = mini_graph_pattern.get_nodes()

        # Fill time_evo_prob_matrix and time_evo_time_matrix
        for mini_node_i in mini_nodes:
            for label in self.graph_labels:
                mini_i = mini_nodes.index(mini_node_i)
                big_i = self.graph_nodes.index(mini_node_i)
                j = self.graph_labels.index(label)

                prob_df = time_evo_prob_matrix[big_i][j]
                prob_df.loc[current_start_date] = mini_prob_matrix[mini_i, j]

                if mini_time_matrix[mini_i][j]:
                    time_df = time_evo_time_matrix[big_i][j]

                    # TODO : Manage with other distribution than &#39;norm&#39;
                    time_df.loc[current_start_date] = [mini_time_matrix[mini_i][j][1][0],
                                                       mini_time_matrix[mini_i][j][1][1]]

        current_start_date += self.period
        evolution_percentage = round(100 * (period_index + 1) / nb_periods, 2)
        sys.stdout.write(&#34;\r{} %% of time evolution computed for the GRAPH NÂ°{}/{}!!&#34;.format(evolution_percentage,
                                                                                             self.ID, nb_patterns))
        sys.stdout.flush()
        period_index += 1
    sys.stdout.write(&#34;\n&#34;)

    self.time_evo_prob_matrix = time_evo_prob_matrix
    self.time_evo_time_matrix = time_evo_time_matrix</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.display"><code class="name flex">
                            <span>def <span
                                    class="ident">display</span></span>(<span>self, output_folder, debug=False)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def display(self, output_folder, debug=False):
    td = dt.timedelta(seconds=self.mu)
    filename = &#39;directed_graph_{}_{}_{}&#39;.format(td.days, td.seconds // 3600, (td.seconds // 60) % 60)

    title = &#39;Period : &#39; + str(self.period) + &#39;\n&#39;
    title += &#39;Mean Time : &#39; + str(td) + &#39;  ---   Std Time : &#39; + str(dt.timedelta(seconds=self.sigma))

    self.draw_directed_graph(filename=output_folder + filename,
                             title=title, debug=debug)</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.draw_directed_graph"><code class="name flex">
                            <span>def <span class="ident">draw_directed_graph</span></span>(<span>self, filename, title, debug=False)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>Draw the directed graph corresponding and save the image
                                :param graph_nodes: Nodes of the graph
                                :param prob_matrix: Transition distance_matrix
                                :param filename: File path where the graph image is saved
                                :param debug: If True, plot the image
                                :return:</p></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def draw_directed_graph(self, filename, title, debug=False):
    &#39;&#39;&#39;
    Draw the directed graph corresponding and save the image
    :param graph_nodes: Nodes of the graph
    :param prob_matrix: Transition distance_matrix
    :param filename: File path where the graph image is saved
    :param debug: If True, plot the image
    :return:
    &#39;&#39;&#39;
    Q = pd.DataFrame(self.prob_matrix)
    Q.columns = self.graph_labels
    Q.index = self.graph_nodes
    edges_wts = self.get_markov_edges(Q)

    # create graph object
    G = nx.MultiDiGraph()

    # graph_nodes correspond to states
    # G.add_nodes_from(self.graph_nodes)

    G.graph[&#39;graph&#39;] = {&#39;label&#39;: title, &#39;labelloc&#39;: &#39;t&#39;, &#39;fontsize&#39;: &#39;20 &#39;, &#39;fontcolor&#39;: &#39;blue&#39;,
                        &#39;fontname&#39;: &#39;times-bold&#39;}  # default
    # edges represent transition probabilities
    for k, prob in edges_wts.items():
        tmp_origin, tmp_destination = k[0], k[1]

        # Add Origin Node
        if tmp_origin == Graph.START_NODE:
            G.add_node(tmp_origin, color=&#39;black&#39;, style=&#39;filled&#39;, fillcolor=&#39;red&#39;)
        else:
            G.add_node(tmp_origin, color=&#39;green&#39;)

        # Add Destination Node
        if tmp_destination == Graph.NONE_NODE:
            G.add_node(tmp_destination, color=&#39;black&#39;, style=&#39;filled&#39;, fillcolor=&#39;blue&#39;)
        else:

            G.add_node(tmp_destination, color=&#39;green&#39;)
            # G.add_node(tmp_destination, color=&#39;green&#39;)

        # Add Edge

        G.add_edge(tmp_origin, tmp_destination, weight=prob, penwidth=2 if prob &gt; 0.5 else 1, label=prob,
                   color=&#39;blue&#39; if prob &gt; 0.5 else &#39;black&#39;)

        # Add Edge with waiting time label
        # G.add_edge(tmp_origin, tmp_destination, weight=v, penwidth=2 if v &gt; 0.5 else 1, label=v,
        #                 color=&#39;blue&#39; if v &gt; 0.5 else &#39;black&#39;,
        #                 headlabel=self.time_matrix[self.graph_nodes.period_ts_index(tmp_origin)][self.labels.period_ts_index(destination_label)])
    if debug:
        print(&#39;Edges:&#39;)
        pprint(G.edges(data=True))
    # pprint(G.graph.get(&#39;graph&#39;, {}))

    pos = nx.drawing.nx_pydot.graphviz_layout(G, prog=&#39;dot&#39;)
    nx.draw_networkx(G, pos)

    # create edge labels for jupyter plot but is not necessary
    edge_labels = {(n1, n2): d[&#39;label&#39;] for n1, n2, d in G.edges(data=True)}

    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

    nx.drawing.nx_pydot.write_dot(G, filename + &#39;.dot&#39;)
    check_call([&#39;dot&#39;, &#39;-Tpng&#39;, filename + &#39;.dot&#39;, &#39;-o&#39;, filename + &#39;.png&#39;])
    self.graph = G
    if debug:
        plt.clf()
        plt.axis(&#39;off&#39;)
        img = mpimg.imread(filename + &#39;.png&#39;)
        plt.imshow(img)
        plt.show()</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.extrapolate_time_evolution"><code class="name flex">
                            <span>def <span class="ident">extrapolate_time_evolution</span></span>(<span>self, start_date)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>Compute the probability transition distance_matrix and the waiting time
                                transition distance_matrix by extrapolating time evolution
                                :param start_date:
                                :param end_date:
                                :return: (prob_matrix, time_matrix)</p></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def extrapolate_time_evolution(self, start_date):
    &#39;&#39;&#39;
    Compute the probability transition distance_matrix and the waiting time transition distance_matrix by extrapolating time evolution
    :param start_date:
    :param end_date:
    :return: (prob_matrix, time_matrix)
    &#39;&#39;&#39;

    n = len(self.graph_nodes)
    l = len(self.graph_labels)
    extr_prob_matrix = np.zeros((n, l))
    extr_time_matrix = [[[] for j in range(l)] for i in range(n)]  # Empty lists

    for i in range(n):
        fig, (ax1, ax2) = plt.subplots(2)
        for j in range(l):
            txt = &#34;--&gt; [{}]&#34;.format(self.graph_labels[j])
            df = self.time_evo_prob_matrix[i][j]
            ax1.plot_date(df.index, df.probability, label=txt, linestyle=&#34;-&#34;)
            df = self.time_evo_time_matrix[i][j]
            ax2.plot_date(df.index, df.mean_time / 60, label=txt, linestyle=&#34;-&#34;)
        ax1.title.set_text(&#39;From Node [{}]\nProbability transition&#39;.format(self.graph_nodes[i]))
        ax1.set_ylabel(&#39;Transition probability&#39;)
        ax2.set_ylabel(&#39;Mean Time (min)&#39;)
        ax2.set_xlabel(&#39;Date&#39;)
        ax2.set_title(&#39;Waiting Time transition&#39;)
        ax1.legend(loc=&#34;upper left&#34;)
        ax2.legend(loc=&#34;upper left&#34;)
        plt.gcf().autofmt_xdate()
        plt.show()</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.generate_activity"><code class="name flex">
                            <span>def <span class="ident">generate_activity</span></span>(<span>self, date, waiting_dist, waiting_param, duration_dist, duration_param)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>Generate a date interval respecting the constraints
                                :param date:
                                :param waiting_dist:
                                :param waiting_param:
                                :param duration_dist:
                                :param duration_param:
                                :return:</p></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def generate_activity(self, date, waiting_dist, waiting_param, duration_dist, duration_param):
    &#34;&#34;&#34;
    Generate a date interval respecting the constraints
    :param date:
    :param waiting_dist:
    :param waiting_param:
    :param duration_dist:
    :param duration_param:
    :return:
    &#34;&#34;&#34;

    waiting_arg = waiting_param[:-2]
    waiting_loc = waiting_param[-2]
    waiting_scale = waiting_param[-1]

    duration_arg = duration_param[:-2]
    duration_loc = duration_param[-2]
    duration_scale = duration_param[-1]

    start_date = None
    end_date = None
    while True:

        waiting_time = int(waiting_dist.rvs(loc=waiting_loc, scale=waiting_scale, *waiting_arg))

        duration = -1
        while duration &lt; 0:
            duration = int(duration_dist.rvs(loc=duration_loc, scale=duration_scale, *duration_arg))

        try:
            start_date = date + dt.timedelta(seconds=waiting_time)
            end_date = start_date + dt.timedelta(seconds=duration)
            break;
        except ValueError as e:
            print(e)
            print(&#34;OOOps ! Date Overflow. Let&#39;s try again...&#34;)

    return start_date, end_date</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.get_date_status"><code class="name flex">
                            <span>def <span class="ident">get_date_status</span></span>(<span>self, start_date)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def get_date_status(self, start_date):
    # We start at the beginning of the first period
    start_date = start_date - dt.timedelta(seconds=modulo_datetime(start_date, self.period))

    n = len(self.graph_nodes)
    l = len(self.graph_labels)

    prob_matrix = [[self.time_evo_prob_matrix[i][j].loc[start_date, &#34;probability&#34;] for j in range(l)] for i in
                   range(n)]
    prob_matrix = np.array(prob_matrix)
    prob_matrix.reshape((n, l))

    time_matrix = [[self.time_evo_time_matrix[i][j].loc[start_date, [&#34;mean_time&#34;, &#34;sigma_time&#34;]].values
                    for j in range(l)] for i in range(n)]
    for i in range(n):
        for j in range(l):
            time_matrix[i][j] = (&#39;norm&#39;, time_matrix[i][j])

    return prob_matrix, time_matrix</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.get_index"><code class="name flex">
                            <span>def <span class="ident">get_index</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def get_index(self):
    return self.ID</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.get_markov_edges"><code class="name flex">
                            <span>def <span class="ident">get_markov_edges</span></span>(<span>self, Q)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>Return the edges of the graph
                                :param Q:
                                :return:</p></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def get_markov_edges(self, Q):
    &#39;&#39;&#39;
    Return the edges of the graph
    :param Q:
    :return:
    &#39;&#39;&#39;
    edges = {}
    for col in Q.columns:
        for idx in Q.index:
            if Q.loc[idx, col] != 0:
                # Build the name of the transition
                lvl = 0
                if idx != Graph.START_NODE:
                    lvl = int(idx[idx.rindex(&#39;_&#39;)+1:]) + 1

                node_name = col
                if col != Graph.NONE_NODE:
                    node_name = col + &#39;_&#39; + str(lvl)
                edges[(idx, node_name)] = round(Q.loc[idx, col], 3)
    return edges</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.get_nodes"><code class="name flex">
                            <span>def <span class="ident">get_nodes</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def get_nodes(self):
    return self.graph_nodes</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.get_prob_matrix"><code class="name flex">
                            <span>def <span class="ident">get_prob_matrix</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def get_prob_matrix(self):
    return self.prob_matrix</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.get_time_matrix"><code class="name flex">
                            <span>def <span class="ident">get_time_matrix</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def get_time_matrix(self):
    return self.time_matrix</code></pre>
                            </details>
                        </dd>
                        <dt id="Graph_Model.Graph_Pattern.Graph.simulate"><code class="name flex">
                            <span>def <span class="ident">simulate</span></span>(<span>self, previous_data, start_date, end_date)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>Simulate the current graph for the given period of time
                                :param start_date:
                                :param end_date:
                                :return:</p></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def simulate(self, previous_data, start_date, end_date):
    &#34;&#34;&#34;
    Simulate the current graph for the given period of time
    :param start_date:
    :param end_date:
    :return:
    &#34;&#34;&#34;
    # self.extrapolate_time_evolution(start_date)
    # prob_matrix, time_matrix = self.get_date_status(start_date)
    # time_matrix = self.time_matrix

    prob_matrix, time_matrix = self.prob_matrix, self.time_matrix

    l = len(self.graph_labels)

    result = pd.DataFrame(columns=[&#34;date&#34;, &#34;end_date&#34;, &#34;label&#34;])

    # The real &#39;start_date&#39; is the beginning of the next period
    start_date_rel = modulo_datetime(start_date, self.period)
    if start_date_rel != 0:
        start_date = start_date + dt.timedelta(seconds=self.period.total_seconds() - start_date_rel)

    current_state = Graph.START_NODE
    current_date = start_date

    while current_date &lt; end_date:
        state_index = self.graph_nodes.index(current_state)
        row = prob_matrix[state_index, :]
        cs_row = np.cumsum(row)

        # Pick a random number between 0 -- 1
        rand = random()
        destination_index = None

        for index in range(l):
            if rand &lt;= cs_row[index]:
                destination_index = index
                break

        if destination_index is None or destination_index == l - 1:  # We reached one end of the graph
            destination_state = Graph.START_NODE # Come back to the beginning

            # We move to the start of the next period
            destination_date = current_date + dt.timedelta(
                seconds=self.period.total_seconds() - modulo_datetime(current_date, self.period))

        else:

            # Turn the column label to a node name
            lvl = 0
            if current_state != Graph.START_NODE:
                lvl = int(current_state[current_state.rindex(&#39;_&#39;) + 1:]) + 1
            destination_state = self.graph_labels[destination_index] + &#39;_&#39; + str(lvl)

            destination_label = destination_state[
                                0: destination_state.rindex(&#39;_&#39;)]  # We remove everything after the last &#39;_&#39;

            tuple = time_matrix[state_index][destination_index]
            dist_name = tuple[0]
            param = tuple[1:][0]
            dist = getattr(st, dist_name)

            activity_duration = self.activities_duration[self.graph_nodes.index(destination_state)]
            duration_dist_name = activity_duration[0]
            duration_param = activity_duration[1:][0]
            duration_dist = getattr(st, duration_dist_name)
            # Separate parts of parameters

            compatibabilty_respected = False

            nb_ite = 10
            activity_start_date, activity_end_date = None, None
            while not compatibabilty_respected &amp; nb_ite &gt; 0:
                nb_ite -= 1
                activity_start_date, activity_end_date = self.generate_activity(current_date, waiting_dist=dist,
                                                                                waiting_param=param,
                                                                                duration_dist=duration_dist,
                                                                                duration_param=duration_param)
                compatibabilty_respected = True

                date_filter = ((previous_data.date &lt; activity_start_date) &amp; (
                        previous_data.end_date &gt; activity_start_date)) | (
                                      (previous_data.end_date &gt; activity_end_date) &amp; (
                                      previous_data.date &lt; activity_end_date)) | (
                                      (previous_data.date &gt; activity_start_date) &amp; (
                                      previous_data.end_date &lt; activity_end_date))

                filtered_data = previous_data.loc[date_filter]
                if not filtered_data.empty:
                    filtered_activities = filtered_data.label.unique()
                    for filtered_activity in filtered_activities:
                        if Graph.COMPATIBILITY_MATRIX[Graph.ACTIVITIES.index(destination_label)][
                            Graph.ACTIVITIES.index(filtered_activity)] == 0:
                            compatibabilty_respected = False

            if nb_ite &gt; 0:
                result.loc[len(result)] = [activity_start_date, activity_end_date, destination_label]
            destination_date = activity_start_date


        current_state = destination_state
        current_date = destination_date

    return result</code></pre>
                            </details>
                        </dd>
                    </dl>
                </dd>
            </dl>
        </section>
    </article>
    <nav id="sidebar">
        <h1>Index</h1>
        <div class="toc">
            <ul></ul>
        </div>
        <ul id="index">
            <li><h3>Super-module</h3>
                <ul>
                    <li><code><a href="index.html" title="Graph_Model">Graph_Model</a></code></li>
                </ul>
            </li>
            <li><h3><a href="#header-functions">Functions</a></h3>
                <ul class="">
                    <li><code><a href="#Graph_Model.Graph_Pattern.random" title="Graph_Model.Graph_Pattern.random">random</a></code>
                    </li>
                </ul>
            </li>
            <li><h3><a href="#header-classes">Classes</a></h3>
                <ul>
                    <li>
                        <h4><code><a href="#Graph_Model.Graph_Pattern.Graph" title="Graph_Model.Graph_Pattern.Graph">Graph</a></code>
                        </h4>
                        <ul class="">
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.ACTIVITIES"
                                         title="Graph_Model.Graph_Pattern.Graph.ACTIVITIES">ACTIVITIES</a></code></li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.COMPATIBILITY_MATRIX"
                                         title="Graph_Model.Graph_Pattern.Graph.COMPATIBILITY_MATRIX">COMPATIBILITY_MATRIX</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.ID"
                                         title="Graph_Model.Graph_Pattern.Graph.ID">ID</a></code></li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.NB_PERIODS_SLIDING_WINDOW"
                                         title="Graph_Model.Graph_Pattern.Graph.NB_PERIODS_SLIDING_WINDOW">NB_PERIODS_SLIDING_WINDOW</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.NONE_NODE"
                                         title="Graph_Model.Graph_Pattern.Graph.NONE_NODE">NONE_NODE</a></code></li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.START_NODE"
                                         title="Graph_Model.Graph_Pattern.Graph.START_NODE">START_NODE</a></code></li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.compute_time_evolution"
                                         title="Graph_Model.Graph_Pattern.Graph.compute_time_evolution">compute_time_evolution</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.display"
                                         title="Graph_Model.Graph_Pattern.Graph.display">display</a></code></li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.draw_directed_graph"
                                         title="Graph_Model.Graph_Pattern.Graph.draw_directed_graph">draw_directed_graph</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.extrapolate_time_evolution"
                                         title="Graph_Model.Graph_Pattern.Graph.extrapolate_time_evolution">extrapolate_time_evolution</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.generate_activity"
                                         title="Graph_Model.Graph_Pattern.Graph.generate_activity">generate_activity</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.get_date_status"
                                         title="Graph_Model.Graph_Pattern.Graph.get_date_status">get_date_status</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.get_index"
                                         title="Graph_Model.Graph_Pattern.Graph.get_index">get_index</a></code></li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.get_markov_edges"
                                         title="Graph_Model.Graph_Pattern.Graph.get_markov_edges">get_markov_edges</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.get_nodes"
                                         title="Graph_Model.Graph_Pattern.Graph.get_nodes">get_nodes</a></code></li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.get_prob_matrix"
                                         title="Graph_Model.Graph_Pattern.Graph.get_prob_matrix">get_prob_matrix</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.get_time_matrix"
                                         title="Graph_Model.Graph_Pattern.Graph.get_time_matrix">get_time_matrix</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.node2label"
                                         title="Graph_Model.Graph_Pattern.Graph.node2label">node2label</a></code></li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.set_compatibility_matrix"
                                         title="Graph_Model.Graph_Pattern.Graph.set_compatibility_matrix">set_compatibility_matrix</a></code>
                            </li>
                            <li><code><a href="#Graph_Model.Graph_Pattern.Graph.simulate"
                                         title="Graph_Model.Graph_Pattern.Graph.simulate">simulate</a></code></li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </nav>
</main>
<footer id="footer">
    <p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>